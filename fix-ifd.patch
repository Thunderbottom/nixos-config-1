From f9e9839bce403f99734682a1eb3e98b14fef7c17 Mon Sep 17 00:00:00 2001
From: Robert Hensing <robert@roberthensing.nl>
Date: Tue, 10 Nov 2020 12:31:59 +0100
Subject: [PATCH] Revert "LocalStore: Get rid of recursive_mutex"

This reverts commit e8c379555fa0441c5ab83b8e5a3a106d69fe2507.
---
 src/libstore/build/derivation-goal.cc |  6 +++---
 src/libstore/local-store.cc           | 23 +++++++----------------
 src/libstore/local-store.hh           |  4 +++-
 src/libstore/path-info.hh             |  2 +-
 src/nix-store/nix-store.cc            |  2 +-
 5 files changed, 15 insertions(+), 22 deletions(-)

diff --git a/src/libstore/build/derivation-goal.cc b/src/libstore/build/derivation-goal.cc
index bf2bad62c84..19d96dd8fda 100644
--- a/src/libstore/build/derivation-goal.cc
+++ b/src/libstore/build/derivation-goal.cc
@@ -3245,7 +3245,7 @@ void DerivationGoal::registerOutputs()
             if (!oldInfo.ultimate) {
                 oldInfo.ultimate = true;
                 worker.store.signPathInfo(oldInfo);
-                worker.store.registerValidPaths({{oldInfo.path, oldInfo}});
+                worker.store.registerValidPaths({ std::move(oldInfo) });
             }
 
             continue;
@@ -3275,7 +3275,7 @@ void DerivationGoal::registerOutputs()
            isn't statically known so that we can safely unlock the path before
            the next iteration */
         if (newInfo.ca)
-            worker.store.registerValidPaths({{newInfo.path, newInfo}});
+            worker.store.registerValidPaths({newInfo});
 
         infos.emplace(outputName, std::move(newInfo));
     }
@@ -3350,7 +3350,7 @@ void DerivationGoal::registerOutputs()
     {
         ValidPathInfos infos2;
         for (auto & [outputName, newInfo] : infos) {
-            infos2.insert_or_assign(newInfo.path, newInfo);
+            infos2.push_back(newInfo);
         }
         worker.store.registerValidPaths(infos2);
     }
diff --git a/src/libstore/local-store.cc b/src/libstore/local-store.cc
index e4e404dca83..2892b0407df 100644
--- a/src/libstore/local-store.cc
+++ b/src/libstore/local-store.cc
@@ -7,7 +7,6 @@
 #include "nar-info.hh"
 #include "references.hh"
 #include "callback.hh"
-#include "topo-sort.hh"
 
 #include <iostream>
 #include <algorithm>
@@ -963,7 +962,9 @@ void LocalStore::querySubstitutablePathInfos(const StorePathCAMap & paths, Subst
 
 void LocalStore::registerValidPath(const ValidPathInfo & info)
 {
-    registerValidPaths({{info.path, info}});
+    ValidPathInfos infos;
+    infos.push_back(info);
+    registerValidPaths(infos);
 }
 
 
@@ -981,7 +982,7 @@ void LocalStore::registerValidPaths(const ValidPathInfos & infos)
         SQLiteTxn txn(state->db);
         StorePathSet paths;
 
-        for (auto & [_, i] : infos) {
+        for (auto & i : infos) {
             assert(i.narHash.type == htSHA256);
             if (isValidPath_(*state, i.path))
                 updatePathInfo(*state, i);
@@ -990,7 +991,7 @@ void LocalStore::registerValidPaths(const ValidPathInfos & infos)
             paths.insert(i.path);
         }
 
-        for (auto & [_, i] : infos) {
+        for (auto & i : infos) {
             auto referrer = queryValidPathId(*state, i.path);
             for (auto & j : i.references)
                 state->stmtAddReference.use()(referrer)(queryValidPathId(*state, j)).exec();
@@ -999,7 +1000,7 @@ void LocalStore::registerValidPaths(const ValidPathInfos & infos)
         /* Check that the derivation outputs are correct.  We can't do
            this in addValidPath() above, because the references might
            not be valid yet. */
-        for (auto & [_, i] : infos)
+        for (auto & i : infos)
             if (i.path.isDerivation()) {
                 // FIXME: inefficient; we already loaded the derivation in addValidPath().
                 checkDerivationOutputs(i.path,
@@ -1013,17 +1014,7 @@ void LocalStore::registerValidPaths(const ValidPathInfos & infos)
            error if a cycle is detected and roll back the
            transaction.  Cycles can only occur when a derivation
            has multiple outputs. */
-        topoSort(paths,
-            {[&](const StorePath & path) {
-                auto i = infos.find(path);
-                return i == infos.end() ? StorePathSet() : i->second.references;
-            }},
-            {[&](const StorePath & path, const StorePath & parent) {
-                return BuildError(
-                    "cycle detected in the references of '%s' from '%s'",
-                    printStorePath(path),
-                    printStorePath(parent));
-            }});
+        topoSortPaths(paths);
 
         txn.commit();
     });
diff --git a/src/libstore/local-store.hh b/src/libstore/local-store.hh
index d4435220df2..5e07261a66a 100644
--- a/src/libstore/local-store.hh
+++ b/src/libstore/local-store.hh
@@ -90,7 +90,9 @@ private:
         std::unique_ptr<PublicKeys> publicKeys;
     };
 
-    Sync<State> _state;
+    // FIXME: get rid of recursive_mutex, it hides recursive SQLite
+    // queries.
+    Sync<State, std::recursive_mutex> _state;
 
 public:
 
diff --git a/src/libstore/path-info.hh b/src/libstore/path-info.hh
index de87f8b33b0..8ff5c466e29 100644
--- a/src/libstore/path-info.hh
+++ b/src/libstore/path-info.hh
@@ -107,6 +107,6 @@ struct ValidPathInfo
     virtual ~ValidPathInfo() { }
 };
 
-typedef std::map<StorePath, ValidPathInfo> ValidPathInfos;
+typedef list<ValidPathInfo> ValidPathInfos;
 
 }
diff --git a/src/nix-store/nix-store.cc b/src/nix-store/nix-store.cc
index 6c2702bfe8a..14baabc36fa 100644
--- a/src/nix-store/nix-store.cc
+++ b/src/nix-store/nix-store.cc
@@ -516,7 +516,7 @@ static void registerValidity(bool reregister, bool hashGiven, bool canonicalise)
                 info->narHash = hash.first;
                 info->narSize = hash.second;
             }
-            infos.insert_or_assign(info->path, *info);
+            infos.push_back(std::move(*info));
         }
     }
 
